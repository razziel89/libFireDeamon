<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libFireDeamon: include/FireDeamon/core/arbitrary_grid_local_minima.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libFireDeamon
   &#160;<span id="projectnumber">1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_68f1df1b69955281240dfd2425339fc3.html">FireDeamon</a></li><li class="navelem"><a class="el" href="dir_f7b4a4efbde27ab3a61c9153900fc2ce.html">core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">arbitrary_grid_local_minima.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header defining functions for searching volumetric data for local minima.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;vector&gt;</code><br />
</div>
<p><a href="arbitrary__grid__local__minima_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7418a4df3de2f53ada541e48047f780e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arbitrary__grid__local__minima_8h.html#a7418a4df3de2f53ada541e48047f780e">make_neighbour_list_irregular</a> (bool progress_reports, int nr_gridpoints, int max_nr_neighbours, int nr_neighbours, int cutoff_type, std::vector&lt; double &gt; points, std::vector&lt; double &gt; distance_cutoff, std::vector&lt; int &gt; *neighbour_list, bool sort_it=true)</td></tr>
<tr class="memdesc:a7418a4df3de2f53ada541e48047f780e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a list of all neighbours of an irregular grid within the given cutoff.  <a href="#a7418a4df3de2f53ada541e48047f780e">More...</a><br /></td></tr>
<tr class="separator:a7418a4df3de2f53ada541e48047f780e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5381cae59359237220faf4dd38781d60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arbitrary__grid__local__minima_8h.html#a5381cae59359237220faf4dd38781d60">make_neighbour_list_regular</a> (bool progress_reports, bool exclude_border, int nr_gridpoints_x, int nr_gridpoints_y, int nr_gridpoints_z, int nr_neighbour_shells, std::vector&lt; int &gt; *neighbour_list)</td></tr>
<tr class="memdesc:a5381cae59359237220faf4dd38781d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a list of all neighbours of a regular grid within the given cutoff.  <a href="#a5381cae59359237220faf4dd38781d60">More...</a><br /></td></tr>
<tr class="separator:a5381cae59359237220faf4dd38781d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc42e3c273876b956475d6023e050197"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="arbitrary__grid__local__minima_8h.html#adc42e3c273876b956475d6023e050197">local_minima_from_neighbour_list</a> (bool progress_reports, int nr_neighbours, int nr_values, std::vector&lt; int &gt; neighbour_list, std::vector&lt; double &gt; values, std::vector&lt; int &gt; *minima, std::vector&lt; double &gt; degeneration_cutoffs, bool use_upper_cutoff=false, bool use_lower_cutoff=false, double upper_cutoff=0.0, double lower_cutoff=0.0, int sort_it=0, std::vector&lt; double &gt; *depths=NULL)</td></tr>
<tr class="memdesc:adc42e3c273876b956475d6023e050197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the indices of local minimum points using a pre-computed neighbour list.  <a href="#adc42e3c273876b956475d6023e050197">More...</a><br /></td></tr>
<tr class="separator:adc42e3c273876b956475d6023e050197"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header defining functions for searching volumetric data for local minima. </p>
<p>The search for local minima is a two-step procedure:</p><ol type="1">
<li>creation of a neighbour list</li>
<li>comparison of each value with those of it's associated neighbours</li>
</ol>
<p>This means that a point is considered to be a local minimum if and only if its associated value is smaller (you can define by how much) than those of its neighbours. First, you should call one of the two functions</p><ul>
<li>make_neighbour_list_irregular and</li>
<li>make_neighbour_list_regular</li>
</ul>
<p>depending on what type of grid your data are defined on. Then, pass the vector containing the neighbour list to local_minima_from_neighbour_list. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="adc42e3c273876b956475d6023e050197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc42e3c273876b956475d6023e050197">&#9670;&nbsp;</a></span>local_minima_from_neighbour_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void local_minima_from_neighbour_list </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>progress_reports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr_neighbours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>neighbour_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>minima</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>degeneration_cutoffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_upper_cutoff</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_lower_cutoff</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upper_cutoff</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lower_cutoff</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sort_it</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>depths</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the indices of local minimum points using a pre-computed neighbour list. </p>
<p>A local minimum is defined as a point whose associated value is smaller than that of all surrounding points (given the degeneration cutoff). Setting a negative degeneration cutoff means that a point has to have an associated value at least the absolute value of the given degeneration cutoff smaller than any sourrounding point to be considered a minimum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progress_reports</td><td>bool - whether or not to give progress reports </td></tr>
    <tr><td class="paramname">nr_neighbours</td><td>int - the number of neighbours each point has (used to separate entries in <em>neighbour_list</em> </td></tr>
    <tr><td class="paramname">nr_values</td><td>int - <em>nr_values</em> times <em>nr_neighbours</em> must be the length of <em>neighbour_list</em> </td></tr>
    <tr><td class="paramname">neighbour_list</td><td>std::vector&lt;int&gt; - what make_neighbour_list_irregular or make_neighbour_list_regular fill </td></tr>
    <tr><td class="paramname">values</td><td>std::vector&lt;double&gt; - the values associated with each point on the grid. If an irregular grid was used, they have to be in the same order as the points that were given to make_neighbour_list_irregular. </td></tr>
    <tr><td class="paramname">minima</td><td>pointer to std::vector&lt;int&gt; - this will be filled with the indices of those points that are local minima </td></tr>
    <tr><td class="paramname">degeneration_cutoffs</td><td>std::vector&lt;double&gt; - the first value will be used a s a degeneration cutoff, i.e., a point's associated value has to be this much larger than that of its neighbours to be considered a local minimum (can be negative) </td></tr>
    <tr><td class="paramname">use_upper_cutoff</td><td>bool - whether or not to use the value in <em>upper_cutoff</em> </td></tr>
    <tr><td class="paramname">use_lower_cutoff</td><td>bool - whether or not to use the value in <em>lower_cutoff</em> </td></tr>
    <tr><td class="paramname">upper_cutoff</td><td>double - a point whose associated value is above this number can never be a minimum </td></tr>
    <tr><td class="paramname">lower_cutoff</td><td>double - a point whose associated value is below this number can never be a minimum </td></tr>
    <tr><td class="paramname">sort_it</td><td>bool - whether or not to sort the resulting minima by their depth </td></tr>
    <tr><td class="paramname">depths</td><td>pointer to std::vector&lt;double&gt; - if not NULL, fill this vector with the depth of the minima (how much "lower" their values are than that of their neighbours) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7418a4df3de2f53ada541e48047f780e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7418a4df3de2f53ada541e48047f780e">&#9670;&nbsp;</a></span>make_neighbour_list_irregular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void make_neighbour_list_irregular </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>progress_reports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr_gridpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_nr_neighbours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr_neighbours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cutoff_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>distance_cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>neighbour_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_it</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a list of all neighbours of an irregular grid within the given cutoff. </p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>segfault (at least undefined behaviour) if <em>max_nr_neighbours</em> is smaller than the number of possible neighbours a point might have </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progress_reports</td><td>bool - whether or not to give progress reports </td></tr>
    <tr><td class="paramname">nr_gridpoints</td><td>int - the total number of points in the grid </td></tr>
    <tr><td class="paramname">max_nr_neighbours</td><td>int - a number larger than the maximum number of points within the cutoff any single point might have </td></tr>
    <tr><td class="paramname">nr_neighbours</td><td>int - the desired number of neighbours per point </td></tr>
    <tr><td class="paramname">cutoff_type</td><td>int - the desired type of metric to compute whether or not points are neighbours, possible values are: - 1: nearest neighbours - 2: Manhattan metric independent for all 3 Cartesian directions - 3: Manhattan metric </td></tr>
    <tr><td class="paramname">points</td><td>std::vector&lt;double&gt; - a flat list of all the point Coordinates of the grid (i.e.: [x1, y1, z1, x2, y2, z2, ..., xN, yN, zN] if N == <em>nr_gridpoints</em> </td></tr>
    <tr><td class="paramname">distance_cutoff</td><td>std::vector&lt;double&gt; - cutoff above which points are no longer considered to be neighbours. If <em>cutoff_type</em> == 1 or 3, only the first entry in distance_cutoff is used. Otherwise, the first three elements are used (cutoff for x, y and z direction, respectively) </td></tr>
    <tr><td class="paramname">neighbour_list</td><td>pointer to std::vector&lt;int&gt; - this vector will be filled with the neighbour list, which is a flat list containing several entries. Each entry consists of the index of a point followed by the indices of its neighbours. If an entry is -1, it is to be ignored. </td></tr>
    <tr><td class="paramname">sort_it</td><td>bool - whether or not to sort each point's neighbours by their distance from it. BEWARE: when set to <em>false</em>, you might not get the nearest neighbours if <em>max_nr_neighbours</em> &gt; <em>nr_neighbours</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5381cae59359237220faf4dd38781d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5381cae59359237220faf4dd38781d60">&#9670;&nbsp;</a></span>make_neighbour_list_regular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void make_neighbour_list_regular </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>progress_reports</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclude_border</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr_gridpoints_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr_gridpoints_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr_gridpoints_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nr_neighbour_shells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>neighbour_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a list of all neighbours of a regular grid within the given cutoff. </p>
<p>Although the parameters are called <em>nr_gridpoints_x</em>, <em>nr_gridpoints_y</em> and <em>nr_gridpoints_z</em>, grids whose axes are not perpendicular to each other can also be treated (by just calling the actual axes x, y and z). All explanations here, however, for the sake of simplicity, assume a cubic grid </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">progress_reports</td><td>bool - whether or not to give progress reports </td></tr>
    <tr><td class="paramname">exclude_border</td><td>bool - whether or not to allow points close to the border to be possible candidates for minima </td></tr>
    <tr><td class="paramname">nr_gridpoints_x</td><td>int - how many points in the first direction the regular grid has </td></tr>
    <tr><td class="paramname">nr_gridpoints_y</td><td>int - how many points in the second direction the regular grid has </td></tr>
    <tr><td class="paramname">nr_gridpoints_z</td><td>int - how many points in the third direction the regular grid has </td></tr>
    <tr><td class="paramname">nr_neighbour_shells</td><td>int - let <em>p</em> be the point we look at, then find all points that lie within a cube whose side length is two times <em>nr_neighbour_shells</em> the grid's lattice constant (e.g., 1 means all 26 points on the first enclosing cube) </td></tr>
    <tr><td class="paramname">neighbour_list</td><td>pointer to std::vector&lt;int&gt; - this vector will be filled with the neighbour list, which is a flat list containing several entries. Each entry consists of the index of a point followed by the indices of its neighbours. If an entry is -1, it is to be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
