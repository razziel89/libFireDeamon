<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libFireDeamon: tuple_it Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libFireDeamon
   &#160;<span id="projectnumber">1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tuple_it Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>namespace containing templates that can be used to perform actions for every entry in a tuple.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtuple__it_1_1gen__seq.html">gen_seq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursively generate a sequence of numbers and keep them in the template information  <a href="structtuple__it_1_1gen__seq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtuple__it_1_1gen__seq_3_010_00_01Is_8_8_8_01_4.html">gen_seq&lt; 0, Is... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the struct that is the end of the recursion  <a href="structtuple__it_1_1gen__seq_3_010_00_01Is_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtuple__it_1_1seq.html">seq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate a sequence of numbers  <a href="structtuple__it_1_1seq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a02dd4e75ba4d851754eb80fcf4aefbdc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , int... Is&gt; </td></tr>
<tr class="memitem:a02dd4e75ba4d851754eb80fcf4aefbdc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetuple__it.html#a02dd4e75ba4d851754eb80fcf4aefbdc">for_each</a> (T *t, F f, <a class="el" href="structtuple__it_1_1seq.html">seq</a>&lt; Is... &gt;)</td></tr>
<tr class="memdesc:a02dd4e75ba4d851754eb80fcf4aefbdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the functor for each element of the tuple. Not to be called directly.  <a href="#a02dd4e75ba4d851754eb80fcf4aefbdc">More...</a><br /></td></tr>
<tr class="separator:a02dd4e75ba4d851754eb80fcf4aefbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9596dbe06429efe2c62d6f310ca4857"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R , typename F , int... Is&gt; </td></tr>
<tr class="memitem:ac9596dbe06429efe2c62d6f310ca4857"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetuple__it.html#ac9596dbe06429efe2c62d6f310ca4857">for_each_vector</a> (T *t, R *r, F f, <a class="el" href="structtuple__it_1_1seq.html">seq</a>&lt; Is... &gt;)</td></tr>
<tr class="memdesc:ac9596dbe06429efe2c62d6f310ca4857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the functor for each element of the tuple. Not to be called directly.  <a href="#ac9596dbe06429efe2c62d6f310ca4857">More...</a><br /></td></tr>
<tr class="separator:ac9596dbe06429efe2c62d6f310ca4857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679e6fe2a33e2c651abf97c89633e121"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename R , typename F &gt; </td></tr>
<tr class="memitem:a679e6fe2a33e2c651abf97c89633e121"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetuple__it.html#a679e6fe2a33e2c651abf97c89633e121">for_each_in_tuple_vector</a> (std::tuple&lt; Ts... &gt; *t, R *r, F f)</td></tr>
<tr class="memdesc:a679e6fe2a33e2c651abf97c89633e121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the functor for each element of the tuple. Can be called directly.  <a href="#a679e6fe2a33e2c651abf97c89633e121">More...</a><br /></td></tr>
<tr class="separator:a679e6fe2a33e2c651abf97c89633e121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82351c96dae5609a8ee7f98e9835a99"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename F &gt; </td></tr>
<tr class="memitem:ad82351c96dae5609a8ee7f98e9835a99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetuple__it.html#ad82351c96dae5609a8ee7f98e9835a99">for_each_in_tuple</a> (std::tuple&lt; Ts... &gt; *t, F f)</td></tr>
<tr class="memdesc:ad82351c96dae5609a8ee7f98e9835a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the functor for each element of the tuple. Can be called directly.  <a href="#ad82351c96dae5609a8ee7f98e9835a99">More...</a><br /></td></tr>
<tr class="separator:ad82351c96dae5609a8ee7f98e9835a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>namespace containing templates that can be used to perform actions for every entry in a tuple. </p>
<p>The "iteration" is no actual iteration as tuples are objects whose lengths have to be fully known at compile time. Access functions also have to be known at compile time. Hence, templating is used to create a sequence 1..N where N is the length of the tuple over which to "iterate". </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a02dd4e75ba4d851754eb80fcf4aefbdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02dd4e75ba4d851754eb80fcf4aefbdc">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , int... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tuple_it::for_each </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtuple__it_1_1seq.html">seq</a>&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the functor for each element of the tuple. Not to be called directly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>pointer to T - the tuple over which to "iterate" (elements will be passed to the functor) </td></tr>
    <tr><td class="paramname">f</td><td>F - the functor who shall be called with <em>t</em> and <em>r</em> as arguments </td></tr>
    <tr><td class="paramname">seq&lt;Is...&gt;</td><td>- a struct that contains the sequence of numbers in its template information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad82351c96dae5609a8ee7f98e9835a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82351c96dae5609a8ee7f98e9835a99">&#9670;&nbsp;</a></span>for_each_in_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tuple_it::for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the functor for each element of the tuple. Can be called directly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>pointer to tuple - the tuple over which to "iterate" (elements will be passed to the functor) </td></tr>
    <tr><td class="paramname">f</td><td>F - the functor who shall be called with <em>t</em> and <em>r</em> as arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a679e6fe2a33e2c651abf97c89633e121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679e6fe2a33e2c651abf97c89633e121">&#9670;&nbsp;</a></span>for_each_in_tuple_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename R , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tuple_it::for_each_in_tuple_vector </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the functor for each element of the tuple. Can be called directly. </p>
<p>This template also allows passing an additional argument to the functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>pointer to tuple - the tuple over which to "iterate" (elements will be passed to the functor) </td></tr>
    <tr><td class="paramname">r</td><td>pointer to R - an argument that will be passed to the functor </td></tr>
    <tr><td class="paramname">f</td><td>F - the functor who shall be called with <em>t</em> and <em>r</em> as arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9596dbe06429efe2c62d6f310ca4857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9596dbe06429efe2c62d6f310ca4857">&#9670;&nbsp;</a></span>for_each_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R , typename F , int... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tuple_it::for_each_vector </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtuple__it_1_1seq.html">seq</a>&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the functor for each element of the tuple. Not to be called directly. </p>
<p>This template also allows passing an additional argument to the functor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>pointer to T - the tuple over which to "iterate" (elements will be passed to the functor) </td></tr>
    <tr><td class="paramname">r</td><td>pointer to R - an argument that will be passed to the functor </td></tr>
    <tr><td class="paramname">f</td><td>F - the functor who shall be called with <em>t</em> and <em>r</em> as arguments </td></tr>
    <tr><td class="paramname">seq&lt;Is...&gt;</td><td>- a struct that contains the sequence of numbers in its template information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
