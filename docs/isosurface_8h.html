<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libFireDeamon: include/FireDeamon/isosurface.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>include/FireDeamon/isosurface.h File Reference</h1>
<p>Function to create an isosurface of arbitrary high quality through volumetric data.  
<a href="#_details">More...</a></p>
<code>#include &lt;vector&gt;</code><br/>

<p><a href="isosurface_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="isosurface_8h.html#af1692401da7165ceddb69c5da001fd04">make_isosurface</a> (std::vector&lt; double &gt; data, std::vector&lt; double &gt; origin, std::vector&lt; double &gt; voxel, std::vector&lt; int &gt; extent, std::vector&lt; double &gt; points_inside, std::vector&lt; double &gt; mesh_criteria, std::vector&lt; double &gt; radii, double relative_precision, double isovalue, std::vector&lt; int &gt; *ivec, std::vector&lt; double &gt; *dvec, std::vector&lt; double &gt; *nvec, std::vector&lt; int &gt; *length)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Function to create an isosurface of arbitrary high quality through volumetric data. </p>
<p>The function <em>make_isosurface</em> has mainly been designed to create isosurfaces arount molecules. It is fast for single molecules but might take longer for multiple molecules (i.e., in the case of non-overlapping isosurfaces) and might not finish if certain conditions are not met. See bugs.</p>
<p>HINT: one isosurface computation is performed for each point specified in <em>points_inside</em>. So declaring only the required minimum (1 in the case of a single molecule) greatly speeds up the computation.</p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000002">Bug:</a></b></dt><dd>The algorithm does not yield the correct iso surface if the points declared in <em>points_inside</em> are not actually located near the isosurface (they don't have to be inside, but they need to be close). This bug is no problem for molecules since its atoms should lie inside the isosurface.</dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000003">Bug:</a></b></dt><dd>The algorithm does not finish if the angular bound mesh criterion (first entry in <em>mesh_criteria</em>) smaller than 30.0 degrees.</dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000004">Bug:</a></b></dt><dd>The algorithm does not finish if the radii given in <em>radii</em> do not define spheres that completely enclose the to-be-generated isosurfaces. </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="af1692401da7165ceddb69c5da001fd04"></a><!-- doxytag: member="isosurface.h::make_isosurface" ref="af1692401da7165ceddb69c5da001fd04" args="(std::vector&lt; double &gt; data, std::vector&lt; double &gt; origin, std::vector&lt; double &gt; voxel, std::vector&lt; int &gt; extent, std::vector&lt; double &gt; points_inside, std::vector&lt; double &gt; mesh_criteria, std::vector&lt; double &gt; radii, double relative_precision, double isovalue, std::vector&lt; int &gt; *ivec, std::vector&lt; double &gt; *dvec, std::vector&lt; double &gt; *nvec, std::vector&lt; int &gt; *length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void make_isosurface </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&nbsp;</td>
          <td class="paramname"> <em>voxel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&nbsp;</td>
          <td class="paramname"> <em>extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&nbsp;</td>
          <td class="paramname"> <em>points_inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&nbsp;</td>
          <td class="paramname"> <em>mesh_criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&nbsp;</td>
          <td class="paramname"> <em>radii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>relative_precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&nbsp;</td>
          <td class="paramname"> <em>ivec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&nbsp;</td>
          <td class="paramname"> <em>dvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; *&nbsp;</td>
          <td class="paramname"> <em>nvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>std::vector&lt;double&gt; - a flat list containing the volumetric data. The order for the indices of the data is: z - fast, y - medium, x - slow </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>origin</em>&nbsp;</td><td>std::vector&lt;double&gt; - a flat list containing the origin point of the data (3 values) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>voxel</em>&nbsp;</td><td>std::vector&lt;double&gt; - a flat list containing the lengths of the voxel sides. This must contain 3 values for x, y and z directions. This means that the voxel vectors need to be parallel to the 3 Cartesian axes. Of course, also non-cuboid voxels can be treated after mapping them to rectangular voxels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>extent</em>&nbsp;</td><td>std::vector&lt;int&gt; - a flat list containing the number of points in x, y and z directions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>points_inside</em>&nbsp;</td><td>std::vector&lt;double&gt; - a flat list containing the Cartesian coordinates for the points that lie within the isosurfaces. The length has to be divisible by 3. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mesh_criteria</em>&nbsp;</td><td>std::vector&lt;double&gt; - a flat list containing the three meshing criteria:</p>
<ol type="1">
<li>Angular bound for surface mesh generation. If &lt;30, the algorithm is not guaranteed to finish. This is the lower bound in degrees for the angles during mesh generation.</li>
<li>Radius bound used during mesh generation. It is an upper bound on the radii of surface Delaunay balls. A surface Delaunay ball is a ball circumscribing a mesh facet and centered on the surface.</li>
<li>Distance bound used during surface mesh generation. It is an upper bound for the distance between the circumcenter of a mesh facet and the center of a surface Delaunay ball of this facet. </li>
</ol>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>radii</em>&nbsp;</td><td>std::vector&lt;double&gt; - a flat list containing radii that, together with the points given in <em>points_inside</em>, define spheres that MUST completely enclose the isosurface that will be generated. I recommend choosing values large enough so that the entire volumetric data set is enclosed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>relative_precision</em>&nbsp;</td><td>double - precision value used to compute the isosurface (given relative to the radii). A lower value results in more highly discretized isosurfaces. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isovalue</em>&nbsp;</td><td>double - the isovalue at which to compute the isosurface </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ivec</em>&nbsp;</td><td>pointer to std::vector&lt;int&gt; - this flat vector will be filled with triples of indices that specify the facets of the isosurface </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dvec</em>&nbsp;</td><td>pointer to std::vector&lt;double&gt; - this flat vector will be filled with triples of values specifying the Cartesian coordinates of the vertices of the isosurface </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nvec</em>&nbsp;</td><td>pointer to std::vector&lt;double&gt; - this flat vector will be filled with triples of values that specify the normal vectors associated with each vertex </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>pointer to std::vector&lt;int&gt; - this flat vector will contain the number of vertices and the number of facets, in that order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 28 Sep 2016 for libFireDeamon by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
