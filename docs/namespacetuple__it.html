<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libFireDeamon: tuple_it Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>tuple_it Namespace Reference</h1>
<p>namespace containing templates that can be used to perform actions for every entry in a tuple.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtuple__it_1_1seq.html">seq</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate a sequence of numbers  <a href="structtuple__it_1_1seq.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtuple__it_1_1gen__seq.html">gen_seq</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">recursively generate a sequence of numbers and keep them in the template information  <a href="structtuple__it_1_1gen__seq.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtuple__it_1_1gen__seq_3_010_00_01Is_8_8_8_4.html">gen_seq&lt; 0, Is...&gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the struct that is the end of the recursion  <a href="structtuple__it_1_1gen__seq_3_010_00_01Is_8_8_8_4.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , int... Is&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetuple__it.html#a2f65a0c0b9b0eb2aad8c8e4ad072f977">for_each</a> (T *t, F f, <a class="el" href="structtuple__it_1_1seq.html">seq</a>&lt; Is...&gt;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate the functor for each element of the tuple. Not to be called directly.  <a href="#a2f65a0c0b9b0eb2aad8c8e4ad072f977"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename R , typename F , int... Is&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetuple__it.html#a5878d0ceb1fc0e36e0d7dd56dae81316">for_each_vector</a> (T *t, R *r, F f, <a class="el" href="structtuple__it_1_1seq.html">seq</a>&lt; Is...&gt;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate the functor for each element of the tuple. Not to be called directly.  <a href="#a5878d0ceb1fc0e36e0d7dd56dae81316"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename R , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetuple__it.html#abf64a43ec5eef7621ee069c04ce64330">for_each_in_tuple_vector</a> (std::tuple&lt; Ts...&gt; *t, R *r, F f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate the functor for each element of the tuple. Can be called directly.  <a href="#abf64a43ec5eef7621ee069c04ce64330"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetuple__it.html#ace2a41e027fa06169c8fbc7aaafdd3a1">for_each_in_tuple</a> (std::tuple&lt; Ts...&gt; *t, F f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluate the functor for each element of the tuple. Can be called directly.  <a href="#ace2a41e027fa06169c8fbc7aaafdd3a1"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>namespace containing templates that can be used to perform actions for every entry in a tuple. </p>
<p>The "iteration" is no actual iteration as tuples are objects whose lengths have to be fully known at compile time. Access functions also have ot be known at compile time. Hence, templating is used to create a sequence 1..N where N is the length of the tuple over which to "iterate". </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a2f65a0c0b9b0eb2aad8c8e4ad072f977"></a><!-- doxytag: member="tuple_it::for_each" ref="a2f65a0c0b9b0eb2aad8c8e4ad072f977" args="(T *t, F f, seq&lt; Is...&gt;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , int... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tuple_it::for_each </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">seq&lt; Is...&gt;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate the functor for each element of the tuple. Not to be called directly. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>pointer to T - the tuple over which to "iterate" (elements will be passed to the functor) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>F - the functor who shall be called with <em>t</em> and <em>r</em> as arguments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>seq&lt;Is...&gt;</em>&nbsp;</td><td>- a struct that contains the sequence of numbers in its template information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace2a41e027fa06169c8fbc7aaafdd3a1"></a><!-- doxytag: member="tuple_it::for_each_in_tuple" ref="ace2a41e027fa06169c8fbc7aaafdd3a1" args="(std::tuple&lt; Ts...&gt; *t, F f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tuple_it::for_each_in_tuple </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts...&gt; *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate the functor for each element of the tuple. Can be called directly. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>pointer to tuple - the tuple over which to "iterate" (elements will be passed to the functor) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>F - the functor who shall be called with <em>t</em> and <em>r</em> as arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf64a43ec5eef7621ee069c04ce64330"></a><!-- doxytag: member="tuple_it::for_each_in_tuple_vector" ref="abf64a43ec5eef7621ee069c04ce64330" args="(std::tuple&lt; Ts...&gt; *t, R *r, F f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename R , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tuple_it::for_each_in_tuple_vector </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; Ts...&gt; *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R *&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&nbsp;</td>
          <td class="paramname"> <em>f</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate the functor for each element of the tuple. Can be called directly. </p>
<p>This template also allows passing an additional argument to the functor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>pointer to tuple - the tuple over which to "iterate" (elements will be passed to the functor) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>pointer to R - an argument that will be passed to the functor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>F - the functor who shall be called with <em>t</em> and <em>r</em> as arguments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5878d0ceb1fc0e36e0d7dd56dae81316"></a><!-- doxytag: member="tuple_it::for_each_vector" ref="a5878d0ceb1fc0e36e0d7dd56dae81316" args="(T *t, R *r, F f, seq&lt; Is...&gt;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R , typename F , int... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tuple_it::for_each_vector </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R *&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">seq&lt; Is...&gt;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate the functor for each element of the tuple. Not to be called directly. </p>
<p>This template also allows passing an additional argument to the functor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>pointer to T - the tuple over which to "iterate" (elements will be passed to the functor) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>pointer to R - an argument that will be passed to the functor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>F - the functor who shall be called with <em>t</em> and <em>r</em> as arguments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>seq&lt;Is...&gt;</em>&nbsp;</td><td>- a struct that contains the sequence of numbers in its template information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 2 Mar 2017 for libFireDeamon by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
