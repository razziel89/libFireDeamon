<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libFireDeamon: FireDeamon Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>FireDeamon Namespace Reference</h1>
<p>Python module for libFireDeamon.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFireDeamon.html#a2243e6cb496522612b50f608e20f094d">SkinSurfacePy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">High level function that wraps the generation of a skin surface.  <a href="#a2243e6cb496522612b50f608e20f094d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFireDeamon.html#af16009f03a79543665267e793ab0deb1">ElectrostaticPotentialPy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">High level function that wraps the computation of the electrostatic potential via multithreaded C++ code.  <a href="#af16009f03a79543665267e793ab0deb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFireDeamon.html#aa78f5bff2934730cef419e7253af3f62">InterpolationPy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">High level function that wraps the interpolation of arbitrary data on an irregular grid via multithreaded C++ code.  <a href="#aa78f5bff2934730cef419e7253af3f62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFireDeamon.html#a1b26b525bc5fd8647a9d09e763395ab2">InitializeGridCalculationOrbitalsPy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize data required to perform some computations on a grid.  <a href="#a1b26b525bc5fd8647a9d09e763395ab2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFireDeamon.html#aeaadc693db7a68a05113debfd55b4388">ElectronDensityPy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the electron density due to molecular orbitals.  <a href="#aeaadc693db7a68a05113debfd55b4388"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFireDeamon.html#a6b2b923c8bce03b735a881ba25e41eaa">NeighbourListPy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">deprecated  <a href="#a6b2b923c8bce03b735a881ba25e41eaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFireDeamon.html#a84f23b0051dcec98f64d408711963c84">IrregularNeighbourListPy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a list of neighbours of each point on an arbitrary grid.  <a href="#a84f23b0051dcec98f64d408711963c84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFireDeamon.html#a84265de3d6f87d07bbd0d01ee479a87b">RegularNeighbourListPy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a list of neighbours of each point on a regular grid.  <a href="#a84265de3d6f87d07bbd0d01ee479a87b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFireDeamon.html#a75e4f829b1a70ff13b25e8abb8194cc5">LocalMinimaPy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a neighbour list (as created by NeighbourListPy), find local minima.  <a href="#a75e4f829b1a70ff13b25e8abb8194cc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFireDeamon.html#abab12e23bb2e098df4ff3fd706f50547">IsosurfacePy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">High level wrapper to create an isosurface of arbitrary high discretization through volumetric data.  <a href="#abab12e23bb2e098df4ff3fd706f50547"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFireDeamon.html#a6e354d08ad6453e606de27bac8388cb6">ElectrostaticPotentialOrbitalsPy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the electron density due to some molecular orbitals on a grid.  <a href="#a6e354d08ad6453e606de27bac8388cb6"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Python module for libFireDeamon. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aeaadc693db7a68a05113debfd55b4388"></a><!-- doxytag: member="FireDeamon::ElectronDensityPy" ref="aeaadc693db7a68a05113debfd55b4388" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def FireDeamon::ElectronDensityPy </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>coefficients_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>occupations</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>volume</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>prog_report</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>detailed_prog</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cutoff</em> = <code>-1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>correction</em> = <code>None</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the electron density due to molecular orbitals. </p>
<div class="fragment"><pre class="fragment">
Calculate the electron density due to some molecular orbitals on a grid.

coefficients_list: list of lists of floats
    The coefficients of the molecular orbitals.
data: what InitializeGridCalculationOrbitalsPy returned

volume: float
    Scale the whole density by the inverse of this value.
prog_report: bool
    Whether or not to give progress reports over MOs.
detailed_prog:
    Whether or not to give progress reports while a MO
    is being treated.
cutoff: float in units of the grid
    No density will be computed if the difference between the
    gridpoint and the center of the basis function is larger
    than this value.
</pre></div> 
</div>
</div>
<a class="anchor" id="a6e354d08ad6453e606de27bac8388cb6"></a><!-- doxytag: member="FireDeamon::ElectrostaticPotentialOrbitalsPy" ref="a6e354d08ad6453e606de27bac8388cb6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def FireDeamon::ElectrostaticPotentialOrbitalsPy </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>coefficients_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>Smat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>occupations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>prog_report</em> = <code>True</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the electron density due to some molecular orbitals on a grid. </p>
<div class="fragment"><pre class="fragment">
Calculate the electron density due to some molecular orbitals on a grid.

coefficients_list: list of lists of floats
    The coefficients of the molecular orbitals.
Smat: list of lists of floats
    The overlap matrix between the primitive Gaussian functions
occupations: a list of floats 
    The occupation number of the corresponding molecular orbital
data: what InitializeGridCalculationOrbitalsPy returned

prog_report: bool
    Whether or not to give progress reports over the grid.
</pre></div> 
</div>
</div>
<a class="anchor" id="af16009f03a79543665267e793ab0deb1"></a><!-- doxytag: member="FireDeamon::ElectrostaticPotentialPy" ref="af16009f03a79543665267e793ab0deb1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def FireDeamon::ElectrostaticPotentialPy </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>charges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>prog_report</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cutoff</em> = <code>10000000.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>High level function that wraps the computation of the electrostatic potential via multithreaded C++ code. </p>
<div class="fragment"><pre class="fragment">
High level function that wraps the computation of the electrostatic potential via
multithreaded C++ code.

points: a list of 3-element elements containing the Cartesian coordinates
        at which to compute the potential
charges: a list of charges at the coordinates
coordinates: a list of 3-element elements containing the Cartesian coordinates
             at which the previously given charges are localized
prog_report: whether or not to get progress reports during the computation
             (since it can take long)
</pre></div> 
</div>
</div>
<a class="anchor" id="a1b26b525bc5fd8647a9d09e763395ab2"></a><!-- doxytag: member="FireDeamon::InitializeGridCalculationOrbitalsPy" ref="a1b26b525bc5fd8647a9d09e763395ab2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def FireDeamon::InitializeGridCalculationOrbitalsPy </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>scale</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>normalize</em> = <code>True</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize data required to perform some computations on a grid. </p>
<div class="fragment"><pre class="fragment">
Create data structures suitable for efficiently computing
the elctron density on an arbitrary grid. Call this first
and then ElectronDensityPy(coefficients_list,data) where data
is what this function returns.

grid: list of [float,float,float]
    The Cartesian coordinates of the grid
basis: a list of [A,L,Prim]
       with
       A: a list of 3 floats
            The center of the contracted Cartesian Gaussian function
       L: a list of 3 ints
            The polynomial exponents of the contracted Cartesian Gaussian
       Prim: a list of [alpha,pre]
            with
            alpha: float
                The exponential factor of the primitive Gaussian function
            pre: float
                The contraction coefficient of the primitive Gaussian function
scale: float, optional (default: 1.0)
    Divide each coordinate by this value (coordinate transformation).
normalize: bool, optional (default: True)
    Whether or not to assume that the Gaussian functions that make up the
    primnitives are normalized or not.
</pre></div> 
</div>
</div>
<a class="anchor" id="aa78f5bff2934730cef419e7253af3f62"></a><!-- doxytag: member="FireDeamon::InterpolationPy" ref="aa78f5bff2934730cef419e7253af3f62" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def FireDeamon::InterpolationPy </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>config</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>prog_report</em> = <code>True</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>High level function that wraps the interpolation of arbitrary data on an irregular grid via multithreaded C++ code. </p>
<div class="fragment"><pre class="fragment">
High level function that wraps the interpolation of arbitrary data
on an irregular grid via multithreaded C++ code.

coordinates: a list of 3-element elements containing the Cartesian coordinates
             at which the given values are localized
vals: a list of values
points: a list of 3-element elements containing the Cartesian coordinates
        at which to interpolate
config: a dictionary of configuration values. Keys are:
            method: the interpolation method ('nearest', 'distance' (for weighted inverse distance))
            for distance, also are needed:
                exponent: exponent for norm
                function: 2 equals Eukledian norm, 3 equals the three norm
prog_report: whether or not to get progress reports during the computation
             (since it can take long)
</pre></div> 
</div>
</div>
<a class="anchor" id="a84f23b0051dcec98f64d408711963c84"></a><!-- doxytag: member="FireDeamon::IrregularNeighbourListPy" ref="a84f23b0051dcec98f64d408711963c84" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def FireDeamon::IrregularNeighbourListPy </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>nr_neighbours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>max_nr_neighbours</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>prog_report</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cutoff_type</em> = <code>'eukledian'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>sort_it</em> = <code>False</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a list of neighbours of each point on an arbitrary grid. </p>
<div class="fragment"><pre class="fragment">
Generate a list of neighbours of each point on an arbitrary grid.

grid: list of [float,float,float]
    The coordinates of each point in the grid.
nr_neighbours: int
    How many neighbours shall be seeked per gridpoint.
cutoff: float or [float,float,float] (depending on cutoff_type)
    Declare the cutoff distance for the given cutoff_type in units
    of the grid.
max_nr_neighbours: int, optional, default: nr_neighbours
    The maximum number of neighbours to be searched per gridpoint.
    This cannot be smaller than nr_neighbours. If the given number
    of neighbours has been found within the given cutoff, no further
    neighbours are being searched. So you might not get the nearest
    ones if this value is too small. Greatly impacts performance.
prog_report: boolean, optional, default: True
    Whether or not information about the progress of the calculation
    should be printed to stdout.
cutoff_type: string, optional, default: eukledian
    define how to determine whether a gridpoint is to far away from
    another to be considered its neighbour. Possible values:
    eukledian:
        The distance is the absolute value of the difference vector.
        Requires cutoff to be one float.
    manhattan_single:
        The sum of the distances in x,y and z directions is the
        distance. Requires cutoff to be one float.
    manhattan_multiple:
        Treat each Cartesian direction independently. Requires
        cutoff to be [float,float,float].
sort_it: boolean, optional, default: False
    Whether or not the neighbours found should be sorted with
    respect to the distance to the given point in increasing order.
</pre></div> 
</div>
</div>
<a class="anchor" id="abab12e23bb2e098df4ff3fd706f50547"></a><!-- doxytag: member="FireDeamon::IsosurfacePy" ref="abab12e23bb2e098df4ff3fd706f50547" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def FireDeamon::IsosurfacePy </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>points_inside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>relative_precision</em> = <code>1.0e-05</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>mesh_criteria</em> = <code>[30</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>High level wrapper to create an isosurface of arbitrary high discretization through volumetric data. </p>
<div class="fragment"><pre class="fragment">
High level wrapper to create an isosurface of arbitrary high discretization
through volumetric data. The data is given on an implicit regular grid in 3
dimensions. One isosurface per element of points_inside is computed and
overlaps are discarded. Using few points for points_inside greatly speeds
up the computation.

WARNING: if points_inside does not fit the data, the algorithm might not
         yield the actual iso surface.
WARNING: the first mesh criterion (angular bound) is &lt;30.0, the algorithm
         is not guaranteed to finish.
HINT: if creating an iso-density-surface around a molecule, it is usually
      sufficient to pass the poisition of only one atom via points_inside.

data: list of N floats
    A flat list of the volumetric data. The order of indices is that of
    dx-files, which is as follows:
        z - fast
        y - middle
        x - slow
origin: list of 3 floats
    The origin of the 3 dimensional regular grid.
counts: list of 3 int
    The number of points in each of the three directions of the grid.
    The product of these three values is the length of 'data'.
delta: a 3x3 matrix (list of 3 lists with 3 elements each)
    The three vectors stored in this parameter form the vertex of the
    regular grid on which the data is defined. The matrix than can be
    built from these vectors must have any values unequal 0.0 solely
    on its main diagonal. This means that the three axes of the grid
    have to be aligned parallel to the three Cartesian axes.
isovalue: float
    The isovalue at which to compute the isosurface.
points_inside: an iterable of [float,float,float]
    Points that are expected to lie inside of (or at least very close to)
    the resulting isosurface. In the case of molecules, this can be the
    atoms' coordinates.
relative_precision: float, optional (default: 1.0e-05)
    Precision value used to compute the isosurface. A lower value results
    in more highly discretized surfaces.
mesh_criteria: a list of A,R,D, all floats. optional (default: [30.0,5.0,5.0]
    Explanations from: http://doc.cgal.org/latest/Surface_mesher/index.html
    A: float
        Angular bound for surface mesh generation. If &lt;30, the algorithm is
        not guaranteed to finish. This is the lower bound in degrees for
        the angles during mesh generation.
    R: float
        Radius bound used during mesh generation. It is an upper bound on
        the radii of surface Delaunay balls. A surface Delaunay ball is a
        ball circumscribing a mesh facet and centered on the surface.
    D: float
        Distance bound used during surface mesh generation. It is an upper
        bound for the distance between the circumcenter of a mesh facet and
        the center of a surface Delaunay ball of this facet.
</pre></div> 
</div>
</div>
<a class="anchor" id="a75e4f829b1a70ff13b25e8abb8194cc5"></a><!-- doxytag: member="FireDeamon::LocalMinimaPy" ref="a75e4f829b1a70ff13b25e8abb8194cc5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def FireDeamon::LocalMinimaPy </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>neighbour_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>degeneration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>nr_neighbours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>prog_report</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>upper_cutoff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>lower_cutoff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>sort_it</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>depths</em> = <code>None</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a neighbour list (as created by NeighbourListPy), find local minima. </p>
<div class="fragment"><pre class="fragment">
Given a neighbour list (as created by NeighbourListPy), find local minima. This is
done by comparing the data at each point to that of its neighbours. The point is
a local minimum if its associated value is at least 'degeneration' lower than that
of all its neighbours.

neighbour_list: std::vector&lt;int&gt; (or SWIG proxy)
    A list of neighbours. The format is: N, N1, N2, N3, ... NM
    and this repeats for every point. M is equal to nr_neighbours
    and N is the number of actual neighbours that have been found
    for the respective point.
values: list of floats
    The volumetric data in which the local minima shall be found.
degeneration: float
    As mentioned in the above description. Can be positive or negative.
prog_report: boolean, optional, default: False
    Whether or not information about the progress of the calculation
    should be printed to stdout.
upper_cutoff: float, optional, default: do not use
    Do not consider points as possible minima whose associated values
    are at least this large.
lower_cutoff: float, optional, default: do not use
    Do not consider points as possible minima whose associated values
    are at most this large.
sort_it: int, optional, default: 1
    If 0, do not sort the minima by depths and do not return the depths.
    If 1, sort the minima with respect to the difference between the value
    at the minimum and the average of all surrounding points. If depths
    is not None, also append the estimated depths.
    If 2, sort the minima with respect to the difference between the value
    at the minimum and the minimum value of all surrounding points. If depths
    is not None, also append the estimated depths.
depths: object that has an 'append' method
    if not None, append to the list (or other object) the estimated
    depths of the minima according to the value of sort_it. If it does
    not have this method, do not append the depths.
</pre></div> 
</div>
</div>
<a class="anchor" id="a6b2b923c8bce03b735a881ba25e41eaa"></a><!-- doxytag: member="FireDeamon::NeighbourListPy" ref="a6b2b923c8bce03b735a881ba25e41eaa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def FireDeamon::NeighbourListPy </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>nr_neighbours</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>max_nr_neighbours</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>prog_report</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>cutoff_type</em> = <code>'eukledian'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>sort_it</em> = <code>False</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>deprecated </p>
<div class="fragment"><pre class="fragment">
Deprecated version of IrregularNeighbourListPy. Will be removed soon.
</pre></div> 
</div>
</div>
<a class="anchor" id="a84265de3d6f87d07bbd0d01ee479a87b"></a><!-- doxytag: member="FireDeamon::RegularNeighbourListPy" ref="a84265de3d6f87d07bbd0d01ee479a87b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def FireDeamon::RegularNeighbourListPy </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>nr_gridpoints_xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>nr_neighbour_shells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>prog_report</em> = <code>True</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a list of neighbours of each point on a regular grid. </p>
<div class="fragment"><pre class="fragment">
Generate a list of neighbours of each point on a regular grid.
Returns a std::vector&lt;int&gt; with (2*nr_neighbour_shells+1)**3-1 elements per gridpoint indicating
how many neighbours there are and which ones are the neighbours. If fewer than the maximum
number of gridpoints was found (e.g. because the point is at a corner), -1's will be added.

nr_gridpoints_xyz: [int, int, int]
    The number of points in each of the three directions of the regular 3D-grid.
nr_neighbour_shells: int
    How many neighbour shells shall be treated (i.e., consider all those points to be
    neighbours who lie inside a cuboid that is spanned by 2*nr_neighbour_shells times the
    vectors that make up the grid. That cuboid is centered around each point.)
prog_report: boolean, optional, default: True
    Whether or not information about the progress of the calculation
    should be printed to stdout.
</pre></div> 
</div>
</div>
<a class="anchor" id="a2243e6cb496522612b50f608e20f094d"></a><!-- doxytag: member="FireDeamon::SkinSurfacePy" ref="a2243e6cb496522612b50f608e20f094d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def FireDeamon::SkinSurfacePy </td>
          <td>(</td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>shrink_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>radii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>refinesteps</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>High level function that wraps the generation of a skin surface. </p>
<div class="fragment"><pre class="fragment">
High level function that wraps the generation of a skin surface.

shrink_factor: shrink factor for the skin surface generation
coordinates: a list of cartesian coordinates declaring the centers of
             the spheres
radii: a list containing all the radii 
refinesteps: refinement steps to perform. 0 will turn it off.
</pre></div> 
</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 28 Sep 2016 for libFireDeamon by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
